# # URL Shortener Task

This nodejs application provides functionality to convert long URLs into short, unique identifiers and retrieve the original URLs using the shortened keys.

## Installation

### Prerequisites

- **Node.js**: Version 16.x or higher.
- **npm**: Package manager for Node.js.

### Clone the Repository
```bash
git clone https://github.com/Nowrose-Irab-Poll/url-shortener-task.git
cd url-shortener-service
```

### Install Dependencies
```bash
npm install
```

### Environment Configuration (Optional)

Create a `.env` file in the root directory with the following variables:

```env
PORT=3000
COUNTER_OFFSET=916132832
BASE_URL=http://localhost:3000
```

---

## Usage

### Start the Application
```bash
npm start
```

By default, the service runs on `http://localhost:3000`.

---

## API Documentation

### 1. **POST /shorten**

Generate a short URL for a given long URL.

#### Request
```json
POST /shorten
Content-Type: application/json
{
  "longUrl": "http://example.com"
}
```

#### Response
```json
{
  "shortUrl": "http://localhost:3000/c0000"
}
```

#### Errors
- **400 Bad Request:** Invalid URL format.

---

### 2. **GET /:shortUrl**

Redirect to the original long URL using a short key.

#### Request
```
GET /c0000
```

#### Response
- **302 Found:** Redirects to the original URL (`http://example.com`).

#### Errors
- **404 Not Found:** Short key does not exist or contains invalid characters.

---

## Testing

The project includes unit and integration tests to ensure correctness and reliability.

### Run Tests
```bash
npm test
```

### Test Coverage
```bash
npm test -- --coverage
```

Test cases cover:
- URL validation logic.
- Base62 encoding and decoding.
- Short URL generation and retrieval.
- API endpoint responses for valid and invalid inputs.

---


## Data Structure for the mapping between original and short URLs:
We use a Map (or HashMap) data structure to store the mappings between original URLs (long URLs) and their corresponding short URLs.

We used base10 Unique Id as key and the provided long URL as value.  

This structure is chosen because:
- Constant Time Complexity: Both insertion and lookup operations are ùëÇ(1), which ensures fast performance even with a large number of URLs.
- Ease of Implementation: Hash-based storage is straightforward and provides a clean API for managing mappings.
- Extensibility: We can easily use a any database as persistent storage when we need with the unique id as primary key

## Approach to Short URL Uniqueness:
- Base62 Encoding with Offset:

  - Each short URL is generated by encoding a unique numeric counter (starting from a predefined counterOffset) into a Base62 string.
  - The counterOffset ensures that all generated keys are at least 6 characters long, which aligns with the requirement.
  - Example:
    - counterOffset = 916132832 (corresponding to the Base62 string baaaaa).
    - Subsequent short URLs increment the counter: baaaab, baaaac, etc.

- Deterministic Key Generation:

  - The counter guarantees uniqueness because it increments monotonically.
  - Each numeric value corresponds to a unique Base62 string, eliminating the risk of collision.


## Techniques to Ensure Short URLs Are Unique and Avoid Conflicts
Incrementing Counter with Offset:

- The counter starts at counterOffset, ensuring all generated short URLs meet the 6-character requirement.
- Incrementing the counter guarantees that each Base62-encoded value is unique.
- This ensures every shortUrl generated to be unique.

So, the incremental Unique Id generation inherently avoids conflict and relieves us from extra burden of rechecking for duplicate Id generation.

## Handling Edge Cases:

- Invalid Long URLs: Validate the URL provided before shortening. 
- Counter Overflow: Add logic to detect when the counter exceeds Number.MAX_SAFE_INTEGER and reset or switch to a BigInt-based system.
- Invalid Short Keys: Validate short URL keys using regex to ensure they conform to Base62 rules.

## Error Handling:

- Handle requests with invalid short URL keys by returning meaningful errors (e.g., "Short URL not found").
- Reject invalid or malformed long URLs during insertion.


## Future Improvements:

- Persistent Storage
  - Currently, the application uses an in-memory Map for storing URL mappings, which is lost when the application restarts.
  - To ensure durability and scalability, integrate a persistent storage solution like:
    - Redis (for fast, in-memory key-value storage).
    - PostgreSQL/MySQL (for persistent relational data storage).

- Caching Strategies for Reads
  - Frequently accessed short URLs can benefit from caching to reduce database load and improve response times.
  - Implement caching mechanisms such as:
    - In-Memory Cache (Redis): Cache popular short URL lookups with a time-to-live (TTL) to ensure freshness.
    - Least Recently Used (LRU) Cache: Use an LRU cache for efficient memory management and to handle high read traffic.
    - Edge Caching with CDNs: Cache URL redirections at the edge (e.g., Cloudflare, AWS CloudFront) for global availability and reduced latency.
